package main

import (
	"encoding/json"
	"fmt"
	"image"
	_ "image/jpeg"
	_ "image/png"
	"io/ioutil"
	"os"
)

type FontConfig struct {
	Config  Config        `json:"config"`
	Kerning []interface{} `json:"kerning"`
	Symbols []Symbols     `json:"symbols"`
}
type Config struct {
	Base          int    `json:"base"`
	Bold          int    `json:"bold"`
	CharHeight    int    `json:"charHeight"`
	CharSpacing   int    `json:"charSpacing"`
	Face          string `json:"face"`
	Italic        int    `json:"italic"`
	LineSpacing   int    `json:"lineSpacing"`
	Size          int    `json:"size"`
	Smooth        int    `json:"smooth"`
	TextureFile   string `json:"textureFile"`
	TextureHeight int    `json:"textureHeight"`
	TextureWidth  int    `json:"textureWidth"`
}
type Symbols struct {
	Height   int `json:"height"`
	ID       int `json:"id"`
	Width    int `json:"width"`
	X        int `json:"x"`
	Xadvance int `json:"xadvance"`
	Xoffset  int `json:"xoffset"`
	Y        int `json:"y"`
	Yoffset  int `json:"yoffset"`
}

var fontInfo FontConfig

func main() {
	if len(os.Args) < 3 {
		fmt.Println("usage: ./converter fontInfoPath.json fontName")
		return
	}
	filename := os.Args[1]
	fontname := os.Args[2]
	f, err := os.Open(filename)
	if err != nil {
		fmt.Printf("Couldnt open `%s`. Did you make a typo in the font name?\n", filename)
	}
	bs, _ := ioutil.ReadAll(f)
	json.Unmarshal(bs, &fontInfo)

	// open image
	img_f, err := os.Open(fontInfo.Config.TextureFile)
	if err != nil {
		fmt.Println("couldn't open texture file. tool only works if fontinfo and font image are in your cwd.")
		return
	}
	img, _, err := image.Decode(img_f)
	if err != nil {
		fmt.Println("found but could not decode the font texture file. is it png or jpg?")
		return
	}
	headerSrc := makeHeader(fontname, img)
	err = saveStrToFile("output/"+fontname+".h", headerSrc)
	if err != nil {
		panic(err)
	}

	sourceSrc := makeSource(fontname, fontInfo, img)
	err = saveStrToFile("output/"+fontname+".cpp", sourceSrc)
	if err != nil {
		panic(err)
	}
}

func saveStrToFile(filename, src string) error {
	f, err := os.Create(filename)
	if err != nil {
		return nil
	}
	_, err = f.Write([]byte(src))
	if err != nil {
		return nil
	}

	err = f.Close()
	if err != nil {
		return nil
	}

	return nil
}

func makeHeader(fontname string, img image.Image) string {
	s := ""
	s += "#pragma once\n"
	s += "#include \"font_common.h\"\n"
	s += "\n"

	s += "// generated by SimVex fontconverter"

	s += "\n\n"

	s += "namespace sim::font{\n"

	s += fmt.Sprintf("extern font_info %s_info;\n\n", fontname)
	s += fmt.Sprintf("extern std::map<char, glyph_info> %s_glyph_info;\n\n", fontname)
	s += fmt.Sprintf("extern const int %s_tex_size;\n", fontname)
	s += fmt.Sprintf("extern const uint8_t %s_tex[%d];\n", fontname, img.Bounds().Dx()*img.Bounds().Dy())

	s += "}\n"

	return s
}

func makeSource(fontname string, fontinfo FontConfig, img image.Image) string {
	s := fmt.Sprintf("#include \"%s.h\"\n", fontname)
	s += "\n"
	s += "// generated by SimVex fontconverter\n"

	s += "namespace sim::font{\n"

	s += fmt.Sprintf("font_info %s_info = {\n\t.size = %d,\n\t.height = %v,\n\t.name = \"%s\"\n};\n", fontname, fontinfo.Config.TextureHeight, fontinfo.Config.Size, fontname)

	s += fmt.Sprintf("std::map<char, glyph_info> %s_glyph_info = {\n", fontname)

	var hasUnknown bool = false

	for _, symbol := range fontinfo.Symbols {
		id := symbol.ID
		x := symbol.X
		width := symbol.Width

		if id > 255 || id == 0 {
			if !hasUnknown {
				hasUnknown = true
				id = 0
			} else {
				continue
			}
		}

		s += fmt.Sprintf("\t{%d, {.x = %d, .width = %d}},\n", id, x, width)
	}
	s += "};\n"

	s += fmt.Sprintf("const int %s_tex_size = %d;\n", fontname, img.Bounds().Dx()*img.Bounds().Dy())
	s += fmt.Sprintf("const uint8_t %s_tex[%s_tex_size] = {\n", fontname, fontname)

	for y := 0; y < img.Bounds().Dy(); y++ {
		for x := 0; x < img.Bounds().Dx(); x++ {
			col := img.At(x, y)
			r, _, _, _ := col.RGBA()
			s += fmt.Sprintf("%d, ", r/256)
		}
	}

	s += "};"

	s += "}\n"
	s += "\n\n"
	return s
}
